name: Update Unlock Data

on:
  schedule:
    # Runs every day at 7:00 AM UTC
    - cron: '0 7 * * *'
  workflow_dispatch:
    # Allows you to trigger manually from the GitHub Actions tab

jobs:
  update:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Fetch unlock data and generate data.js
        env:
          COINGLASS_API_KEY: ${{ secrets.COINGLASS_API_KEY }}
        run: |
          node << 'EOF'
          const https = require('https');
          const fs = require('fs');

          const API_KEY = process.env.COINGLASS_API_KEY;
          const BASE_URL = 'open-api-v4.coinglass.com';

          // ─── Fetch helper ────────────────────────────────────────────────────
          function fetchJSON(path) {
            return new Promise((resolve, reject) => {
              const options = {
                hostname: BASE_URL,
                path,
                method: 'GET',
                headers: {
                  'CG-API-KEY': API_KEY,
                  'Content-Type': 'application/json',
                },
              };
              const req = https.request(options, res => {
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => {
                  try { resolve(JSON.parse(data)); }
                  catch (e) { reject(new Error(`Failed to parse JSON: ${data.slice(0,200)}`)); }
                });
              });
              req.on('error', reject);
              req.setTimeout(15000, () => { req.destroy(); reject(new Error('Request timeout')); });
              req.end();
            });
          }

          // ─── Sleep helper (respect rate limits) ─────────────────────────────
          const sleep = ms => new Promise(r => setTimeout(r, ms));

          // ─── Thresholds for fetching vesting detail ──────────────────────────
          const VESTING_USD_THRESHOLD  = 100000;  // fetch vesting if unlock > $100k
          const VESTING_PCT_THRESHOLD  = 0.5;     // or if > 0.5% of circulating

          async function main() {
            console.log('Fetching token unlock list...');
            const listRes = await fetchJSON('/api/coin/unlock-list');

            if (listRes.code !== '0' || !Array.isArray(listRes.data)) {
              throw new Error(`Unexpected response from unlock-list: ${JSON.stringify(listRes).slice(0,300)}`);
            }

            const now = Date.now();
            const thirtyDays = 180 * 24 * 60 * 60 * 1000;

            // Filter to next 30 days and dedupe by symbol
            const seen = new Set();
            const tokens = listRes.data.filter(t => {
              const dt = t.next_unlock_date;
              if (!dt) return false;
              if (seen.has(t.symbol)) return false;
              seen.add(t.symbol);
              return dt >= now && dt <= now + thirtyDays;
            });
            console.log('Raw API sample:', JSON.stringify(listRes.data.slice(0,2)));
            console.log(`Found ${tokens.length} tokens with unlocks in next 30 days`);

            // Normalize base fields
            const normalized = tokens.map(t => ({
              symbol:             t.symbol,
              name:               t.name,
              price:              t.price || 0,
              price_change_24h:   t.price_change_percent_24h ?? null,
              market_cap:         t.market_cap || 0,
              next_unlock_date:   t.next_unlock_date,
              next_unlock_usd:    t.next_unlock_usd || 0,
              next_unlock_tokens: t.next_unlock_tokens || 0,
              pct_circ:           (t.next_unlock_of_circulating || 0) * (t.next_unlock_of_circulating > 1 ? 1 : 100),
              pct_supply:         (t.next_unlock_of_supply || 0) * (t.next_unlock_of_supply > 1 ? 1 : 100),
              allocation_type:    null,
              vesting_type:       null,
            }));

            // Fix pct values — API returns them as decimals (0.09) meaning 0.09%
            // but sometimes as whole numbers for large unlocks. Normalize:
            for (const t of normalized) {
              // If pct_circ looks like it's already a percentage (> 0 and came from
              // next_unlock_of_circulating which the API gives as a raw decimal like 0.0909)
              // multiply by 100 to get the actual %
              t.pct_circ   = (t.next_unlock_tokens / 1) && t.pct_circ < 10
                ? t.pct_circ  // already looks right from API sample data
                : t.pct_circ;
              t.pct_supply = t.pct_supply;
            }

            // Fetch vesting details for significant tokens
            const significant = normalized.filter(t =>
              t.next_unlock_usd >= VESTING_USD_THRESHOLD ||
              t.pct_circ >= VESTING_PCT_THRESHOLD
            );

            console.log(`Fetching vesting detail for ${significant.length} significant tokens...`);

            for (const token of significant) {
              try {
                await sleep(300); // 300ms between requests
                console.log(`  → ${token.symbol}`);
                const vestRes = await fetchJSON(`/api/token-vesting?symbol=${token.symbol}`);

                if (vestRes.code === '0' && vestRes.data) {
                  const data = vestRes.data;
                  // Find the allocation that has the next unlock
                  const activeAlloc = (data.allocations || []).find(a =>
                    !a.is_untracked &&
                    a.next_unlock &&
                    a.next_unlock.date === token.next_unlock_date
                  );
                  if (activeAlloc) {
                    token.allocation_type = activeAlloc.name;
                    token.vesting_type    = activeAlloc.unlock_type || null;
                  }
                }
              } catch (err) {
                console.warn(`  ⚠ Failed to fetch vesting for ${token.symbol}: ${err.message}`);
              }
            }

            // Write data.js
            const meta = {
              generated_at: new Date().toISOString(),
              token_count: normalized.length,
              source: 'Coinglass API v4',
            };

            const output = [
              `// Auto-generated by GitHub Actions — do not edit manually`,
              `// Last updated: ${meta.generated_at}`,
              `const UNLOCK_DATA = ${JSON.stringify(normalized, null, 2)};`,
              `const UNLOCK_META = ${JSON.stringify(meta, null, 2)};`,
            ].join('\n\n');

            fs.writeFileSync('data.js', output, 'utf8');
            console.log(`✓ Wrote data.js with ${normalized.length} tokens`);
          }

          main().catch(err => {
            console.error('Fatal error:', err);
            process.exit(1);
          });
          EOF

      - name: Commit and push data.js
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add data.js
          # Only commit if data.js actually changed
          git diff --staged --quiet || git commit -m "chore: update unlock data $(date -u +'%Y-%m-%d %H:%M UTC')"
          git push
